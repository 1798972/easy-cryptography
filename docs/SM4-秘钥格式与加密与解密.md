# 1.背景

SM4是对称算法，通俗来说，即加密和解密使用的是同一个秘钥。



# 2.秘钥格式

SM4 密钥长度固定为 128 位（16 字节），任何不同长度的密钥都将被视为无效。

密钥可以是任何 16 字节的二进制数据，通常密钥由一个随机数生成器产生，确保其不可预测性和高安全性。



# 3.加密解密

## 3.1 加密模式

> SM4中，我们尝尝会接触到所谓的ECB和CBC。

**SM4、AES、DES等是块加密算法（Block Cipher Algorithm）。**

块加密算法将明文数据按固定长度（块大小）分块处理，每个块独立加密或解密。

**块大小（Block Size）**即每次加密或解密操作处理的数据长度，通常为固定长度，如128位（16字节）或64位（8字节）。

SM4和AES的块大小都是128位（16字节）。

咱们这个加密到底咋处理，就有了下面的加密模式。

### 3.1.1 ECB

每个数据块独立加密，不使用任何额外信息。

- **优点**：简单易实现。
- **缺点**：相同的明文块会生成相同的密文块，容易受到模式分析攻击。
- **适用场景**：不推荐用于加密大数据量的信息，适用于加密小量的独立数据块。

### 3.1.2 CBC

每个数据块与前一个密文块进行异或操作后再加密。

第一个数据块与**初始化向量（IV）**进行异或（IV 长度通常与块大小相同）。

- **优点**：相同的明文在不同的上下文中会生成不同的密文块。
- **缺点**：依赖前一个密文块，无法并行处理。
- **适用场景**：推荐用于一般数据加密。

### 3.1.3 CFB

将前一个密文块加密后的结果与当前明文块进行异或操作生成当前密文块，第一个密文块与初始化向量（IV）进行异或。

- **优点**：可以加密小于块大小的数据，可以进行流加密。
- **缺点**：依赖前一个密文块，无法并行处理。
- **适用场景**：适用于流数据的加密。

### 3.1.4 OFB

使用前一个加密结果（而不是密文块）与当前明文块进行异或操作，生成当前密文块，第一个结果由初始化向量（IV）生成。

- **优点**：可以加密小于块大小的数据，可以进行流加密，错误不会传播。
- **缺点**：依赖前一个加密结果，无法并行处理。
- **适用场景**：适用于流数据的加密。

### 3.1.5 CTR

使用一个计数器对块进行加密，然后将结果与明文块进行异或。

- **优点**：可以并行处理块，适合高性能需求。
- **缺点**：计数器需要唯一且不可预测。
- **适用场景**：适用于并行加密，高性能需求场景。



## 3.2 填充模式

由于块加密算法要求数据长度是块大小的整数倍，当明文数据长度不足一个块大小时，需要填充数据以满足块大小的要求。

### 3.2.1 PKCS#5 填充

PKCS#5 填充是最早的填充标准之一，专门为块大小为 8 字节（64 位）的块加密算法设计。

#### A.规则

- 将数据长度填充到块大小的整数倍。
- 如果数据已经是块大小的整数倍，则添加一个完整块的填充。
- 每个填充字节的值为填充字节的数量（看差几个）。

#### B.示例

假设块大小为 8 字节：

```tex
明文: "123456"（6字节）
块大小: 8字节
PKCS#5填充后: "123456\x02\x02"  (2个 0x02填充字节)
```

再假设块大小为 8 字节，明文长度正好是块大小的整数倍：

```tex
明文: "12345678"（8字节）
块大小: 8字节
PKCS#5填充后: "12345678\x08\x08\x08\x08\x08\x08\x08\x08"  (8个0x08 填充字节)
```

#### C.注意

在使用 PKCS#5 和 PKCS#7 填充时，**即使明文长度刚好是块大小的整数倍，也需要添加一个完整块的填充**，这是为了确保解密时能够明确知道填充的长度。

当解密时，需要知道填充的长度以去除填充字节。

如果不添加完整的填充块，解密时无法确定最后一个字节是实际数据还是填充字节。

因此，PKCS#5 和 PKCS#7 填充标准规定，即使数据长度是块大小的整数倍，也要添加一个完整块的填充。

例如上面的例子里。

解密时，通过检查最后一个字节的值，确定填充的长度，从而正确移除填充：

- 如果最后一个字节的值是 2（0x02），说明需要移除 2 个字节的填充。
- 如果最后一个字节的值是 8（0x08），说明需要移除 8 个字节的填充。

通过这种方式，解密算法可以准确地去除填充，恢复原始数据。



### 3.2 PKCS#7 填充

PKCS#7 填充是 PKCS#5 的扩展，适用于任意块大小的加密算法。

#### A.规则

- 将数据长度填充到块大小的整数倍。
- 如果数据已经是块大小的整数倍，则添加一个完整块的填充。
- 每个填充字节的值为填充字节的数量（看差几个）。

#### B.示例

假设块大小为 16 字节：

```tex
明文: "1234567890"（10字节）
块大小: 16字节
PKCS#7填充后: "1234567890\x06\x06\x06\x06\x06\x06"  (6个0x06填充字节)
```

假设块大小为 16 字节，明文长度正好是块大小的整数倍：

```tex
明文: "1234567890123456"（16字节）
块大小: 16字节
PKCS#7填充后: "1234567890123456\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10"  (16个0x10 填充字节)
```



### 3.3 Zero 填充

Zero 填充通过在数据末尾添加 0x00 字节来填充数据，直到数据长度是块大小的整数倍。

#### A.规则

- 在数据末尾添加 **0x00** 字节，直到数据长度为块大小的整数倍。
- 如果数据已经是块大小的整数倍，则不需要填充。

#### B.示例

假设块大小为 8 字节：

```tex
明文: "123456"（6字节）
块大小: 8字节
Zero填充后: "123456\x00\x00"  (2个0x00 填充字节)
```

再假设块大小为 8 字节，明文长度正好是块大小的整数倍：

```tex
明文: "12345678"（8字节）
块大小: 8字节
Zero填充后: "12345678"  (不需要填充)
```

#### C.事项

如果明文本身包含尾部的 0x00 字节，在解密时可能会误认为是填充字节，导致数据丢失。

因此，Zero 填充适用于明确知道数据尾部不会包含 0x00 字节的场景。